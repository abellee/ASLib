package{		import flash.events.MouseEvent;	import flash.events.Event;	import flash.geom.Point;	import flash.display.Shape;	import flash.display.MovieClip;	import flash.display.Stage;	import flash.media.Sound;	import flash.media.SoundTransform;	import flash.media.SoundChannel;		public class PageFlipping extends MovieClip{				private var stageWidth:Number = stage.stageWidth;		private var stageHeight:Number = stage.stageHeight;		private var pointA:Point = new Point(0,0);		private var pointB:Point = new Point(stageWidth,0);		private var pointC:Point = new Point(0,stageHeight);		private var pointD:Point = new Point(stageWidth,stageHeight);		private var pointG:Point = new Point(stageWidth/2,stageHeight/2);		private var pointH:Point = new Point();		private var pointI:Point = new Point();		private var pointL:Point = new Point();		private var pointK:Point = new Point();		private var pointM:Point = new Point(); // mouseX mouseY		private var masker:Shape = new Shape();		private var masker1:Shape = new Shape();		private var shadowMasker:Shape = new Shape();		private var n:uint = 1;   // page number counter		private var flipping:Boolean = false;		private var pages:uint = 5;  //page sum           此处的数字代表总页数！		private var snd:FlipSound = new FlipSound();		private var sndTransform:SoundTransform = new SoundTransform();		private var sndChannel:SoundChannel = new SoundChannel();				public function PageFlipping():void{						hidePages();			sndTransform.volume = 1.0;			this.addEventListener(Event.ENTER_FRAME,checkFlipState);			stage.addEventListener(MouseEvent.MOUSE_UP,mouseUpHandler);			flipLeft.addEventListener(MouseEvent.MOUSE_DOWN,mouseDownHandler);					}		private function hidePages():void{						flipRight.visible = false;			for(var i:uint = 1 ;i<(pages+1); i++){								this["p"+i].visible = false							}					}		private function mouseClickHandler(e:MouseEvent):void{						if(masker){								this.removeChild(masker);				this.removeChild(masker1);				this.removeChild(shadowMasker);							}			this.removeEventListener(Event.ENTER_FRAME,beginFlipping);			flipLeft.removeEventListener(MouseEvent.MOUSE_DOWN,mouseDownHandler);			this.setChildIndex(this["mc"+n],(this.numChildren-4));			this.setChildIndex(this["p"+n],(this.numChildren-5));			if(flipping){								if(!sndChannel.position){										sndChannel = snd.play(0,1,sndTransform);					sndChannel.addEventListener(Event.SOUND_COMPLETE,resumeSound);									}				this.addEventListener(Event.ENTER_FRAME,clickToFlip);							}					}		private function clickToFlip(e:Event):void{						pointM.x += (0-pointM.x)/4;			pointM.y += (stageHeight-pointM.y)/4;			beginDrawing();					}		private function checkFlipState(e:Event):void{						if(n > 1){								flipRight.visible = true;				flipRight.addEventListener(MouseEvent.MOUSE_DOWN,down_flipRight);							}else{								flipRight.visible = false;							}			if(flipping)			{								flipLeft.removeEventListener(MouseEvent.MOUSE_DOWN,mouseDownHandler);				//flipRight.removeEventListener(MouseEvent.MOUSE_DOWN,mouseDownHandler);							}			else{								flipLeft.addEventListener(MouseEvent.MOUSE_DOWN,mouseDownHandler);				stage.addEventListener(MouseEvent.MOUSE_UP,mouseUpHandler);				//flipRight.addEventListener(MouseEvent.MOUSE_DOWN,mouseDownHandler);											}					}		private function mouseDownHandler(e:MouseEvent):void{						flipping = true;			trace(this.numChildren);			this.setChildIndex(this["mc"+n],(this.numChildren-4));			this.setChildIndex(this["p"+n],(this.numChildren-5));			this.addEventListener(Event.ENTER_FRAME,beginFlipping);					}		private function beginFlipping(e:Event):void{						if(mouseX > stageWidth && mouseY < stageHeight && mouseX > 0){															}else if(mouseX < stageWidth && mouseX > 0 && mouseY > stageHeight){															}else if(mouseX >= 0 && mouseX <= stageWidth && mouseY >= 0 && mouseY <= stageHeight && hitCircle.hitTestPoint(mouseX,mouseY,true) == true){								pointM.x = mouseX;				pointM.y = mouseY;				beginDrawing();							}else if(mouseX >= 0 && mouseX <= stageWidth && mouseY >= 0 && mouseY <= stageHeight && hitCircle.hitTestPoint(mouseX,mouseY,true) == false){								pointM.x = mouseX;				var angle:Number				angle = Math.acos(Math.abs((mouseX - stageWidth/2))/(stageWidth/2));				pointM.y = stageHeight-Math.sin(angle)*(stageWidth/2);				beginDrawing();							}		}		private function mouseUpHandler(e:MouseEvent):void{						this.removeEventListener(Event.ENTER_FRAME,beginFlipping);			if(flipping){								if(!sndChannel.position){										stage.removeEventListener(MouseEvent.MOUSE_UP,mouseUpHandler);					sndChannel = snd.play(0,1,sndTransform);					sndChannel.addEventListener(Event.SOUND_COMPLETE,resumeSound);									}				this.addEventListener(Event.ENTER_FRAME,autoFlipping);							}					}		private function resumeSound(e:Event):void{						sndChannel.stop();			sndChannel.removeEventListener(Event.SOUND_COMPLETE,resumeSound);					}		private function autoFlipping(e:Event):void{					if(pointM.x >= stageWidth/2){								pointM.x += (stageWidth-pointM.x)/4;								if(pointM.x >= (stageWidth-0.1)){										shadowMC.x = stageWidth+100;					removeChild(masker1);					removeChild(shadowMasker);					removeChild(masker);					this.removeEventListener(Event.ENTER_FRAME,autoFlipping);					flipping = false;					return;								}							}else{								pointM.x += (0-pointM.x)/4;				if(pointM.x <= 0.1){										flipLeft.addEventListener(MouseEvent.MOUSE_DOWN,mouseDownHandler);					stage.addEventListener(MouseEvent.MOUSE_UP,mouseUpHandler);					removeChild(masker1);					this["p"+n].mask = null;					this["mc"+n].x = 0;					this["mc"+n].y = stageHeight;					this["mc"+n].mask = null;					this["mc"+n].getChildAt(0).x = -stageWidth;					shadowMC.x = stageWidth+100;					removeChild(shadowMasker);					removeChild(masker);					this.removeEventListener(Event.ENTER_FRAME,autoFlipping);					flipping = false;					if(n == pages){												flipLeft.visible = false;											}else{												n++;											}					return;								}							}			pointM.y += (stageHeight-pointM.y)/4;			beginDrawing();					}		private function beginDrawing():void{						this["mc"+n].x = pointM.x;			this["mc"+n].y = pointM.y;			var md:Number = Point.distance(pointD,pointM);			var dl:Number = stageWidth-pointM.x;			var ml:Number = stageHeight-pointM.y;			var mdl:Number = Math.atan2(ml,dl);			var dh:Number = md/2/Math.sin(mdl);			pointH.x = pointD.x;			pointH.y = pointD.y-dh;			pointI.x = pointD.x - md/2/Math.cos(mdl);			pointI.y = pointD.y;			if(pointH.y>pointB.y){								pointK.x = pointH.x;				pointK.y = pointH.y;							}else{								var bh:Number = Math.tan(mdl)*(dh-stageHeight);				if(!bh){					bh = stageWidth/2;									}				var kha:Number = mdl*2;				pointK.x = pointB.x - (Math.cos(mdl/2)*bh+bh)				pointK.y = -(Math.sin(kha)*bh);				pointH.x = pointB.x - bh;				pointH.y = pointB.y;							}			masker.graphics.clear();			masker.graphics.beginFill(0x000000,1.0);			masker.graphics.moveTo(pointM.x,pointM.y);			masker.graphics.lineTo(pointK.x,pointK.y);			masker.graphics.lineTo(pointH.x,pointH.y);			masker.graphics.lineTo(pointI.x,pointI.y);			masker.graphics.lineTo(pointM.x,pointM.y);			masker.graphics.endFill();			this["mc"+n].rotation = 2*mdl*180/Math.PI;			addChild(masker);			this["mc"+n].mask = masker;			shadowMasker.graphics.clear();			shadowMasker.graphics.beginFill(0x000000,1.0);			shadowMasker.graphics.moveTo(pointM.x,pointM.y);			shadowMasker.graphics.lineTo(pointK.x,pointK.y);			shadowMasker.graphics.lineTo(pointH.x,pointH.y);			shadowMasker.graphics.lineTo(pointB.x,pointB.y);			shadowMasker.graphics.lineTo(pointD.x,pointD.y);			shadowMasker.graphics.lineTo(pointI.x,pointI.y);			shadowMasker.graphics.lineTo(pointM.x,pointM.y);			shadowMasker.graphics.endFill();			addChild(shadowMasker);			shadowMC.mask = shadowMasker;			shadowMC.x = pointI.x-47;			shadowMC.y = pointI.y;			shadowMC.rotation = mdl*180/Math.PI;			masker1.graphics.clear();			masker1.graphics.beginFill(0x000000,1.0);			masker1.graphics.moveTo(pointD.x,pointD.y);			masker1.graphics.lineTo(pointI.x,pointI.y);			masker1.graphics.lineTo(pointH.x,pointH.y);			masker1.graphics.lineTo(pointB.x,pointB.y);			masker1.graphics.lineTo(pointD.x,pointD.y);			masker1.graphics.endFill();			addChild(masker1);			this["p"+n].mask = masker1;			this["p"+n].visible = true;					}				/************************************************/		/***************** flip to right ****************/		/************************************************/		private function down_flipRight(e:MouseEvent):void{						//....					}			}	}