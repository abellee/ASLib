package{		import flash.events.MouseEvent;	import flash.events.Event;	import flash.geom.Point;	import flash.display.Shape;	import flash.display.MovieClip;	import flash.display.Stage;	import flash.media.Sound;	import flash.media.SoundTransform;	import flash.media.SoundChannel;		public class PageFlipping extends MovieClip{				private var stageWidth:Number = stage.stageWidth;		private var stageHeight:Number = stage.stageHeight;		private var pointA:Point = new Point(0,0);		private var pointB:Point = new Point(stageWidth,0);		private var pointC:Point = new Point(0,stageHeight);		private var pointD:Point = new Point(stageWidth,stageHeight);		private var pointG:Point = new Point(stageWidth/2,stageHeight/2);		private var pointH:Point = new Point();		private var pointI:Point = new Point();		private var pointL:Point = new Point();		private var pointK:Point = new Point();		private var pointM:Point = new Point(); // mouseX mouseY		private var masker:Shape = new Shape();		private var masker1:Shape = new Shape();		private var shadowMasker:Shape = new Shape();		private var n:uint = 1;   // page number counter		private var flipping:Boolean = false;		private var pages:uint = 5;  //page sum           此处的数字代表总页数！		private var pageDirect:String;		private var snd:FlipSound = new FlipSound();		private var sndTransform:SoundTransform = new SoundTransform();		private var sndChannel:SoundChannel = new SoundChannel();				public function PageFlipping():void{						hidePages();			sndTransform.volume = 1.0;			this.addEventListener(Event.ENTER_FRAME,checkFlipState);			stage.addEventListener(MouseEvent.MOUSE_UP,mouseUpHandler);			flipLeft.addEventListener(MouseEvent.MOUSE_DOWN,mouseDownHandler);					}		private function hidePages():void{						flipRight.visible = false;			for(var i:uint = 0 ;i<(pages+1); i++){								this["p"+i].visible = false							}					}				//click button to flip				private function mouseClickHandler(e:MouseEvent):void{						if(masker){								this.removeChild(masker);				this.removeChild(masker1);				this.removeChild(shadowMasker);							}			this.removeEventListener(Event.ENTER_FRAME,beginFlipping);			flipLeft.removeEventListener(MouseEvent.MOUSE_DOWN,mouseDownHandler);			this.setChildIndex(this["mc"+n],(this.numChildren-4));			this.setChildIndex(this["p"+n],(this.numChildren-5));			if(flipping){								if(!sndChannel.position){										sndChannel = snd.play(0,1,sndTransform);					sndChannel.addEventListener(Event.SOUND_COMPLETE,resumeSound);									}				this.addEventListener(Event.ENTER_FRAME,clickToFlip);							}					}		private function clickToFlip(e:Event):void{						pointM.x += (0-pointM.x)/4;			pointM.y += (stageHeight-pointM.y)/4;			beginDrawing();					}				//				private function checkFlipState(e:Event):void{						if(n > 1){								flipRight.visible = true;				flipRight.addEventListener(MouseEvent.MOUSE_DOWN,down_flipRight);							}else{								flipRight.visible = false;							}			if(flipping)			{								flipLeft.removeEventListener(MouseEvent.MOUSE_DOWN,mouseDownHandler);				flipRight.removeEventListener(MouseEvent.MOUSE_DOWN,down_flipRight);							}			else{								flipLeft.addEventListener(MouseEvent.MOUSE_DOWN,mouseDownHandler);				stage.addEventListener(MouseEvent.MOUSE_UP,mouseUpHandler);				flipRight.addEventListener(MouseEvent.MOUSE_DOWN,down_flipRight);											}					}		private function mouseDownHandler(e:MouseEvent):void{			trace(this.numChildren);			flipping = true;			pageDirect = "left";			this.setChildIndex(this["mc"+n],(this.numChildren-4));			this.setChildIndex(this["p"+n],(this.numChildren-5));			this.addEventListener(Event.ENTER_FRAME,beginFlipping);					}		private function beginFlipping(e:Event):void{						if(mouseX > stageWidth && mouseY < stageHeight && mouseX > 0){															}else if(mouseX < stageWidth && mouseX > 0 && mouseY > stageHeight){															}else if(mouseX > 0 && mouseX < stageWidth && mouseY > 0 && mouseY < stageHeight && hitCircle.hitTestPoint(mouseX,mouseY,true) == true){								pointM.x = mouseX;				pointM.y = mouseY;				if(pageDirect == "left"){									beginDrawing();								}else{									rightFlipDrawing();								}							}else if(mouseX > 0 && mouseX < stageWidth && mouseY > 0 && mouseY < stageHeight && hitCircle.hitTestPoint(mouseX,mouseY,true) == false){								pointM.x = mouseX;				var angle:Number				angle = Math.acos(Math.abs((mouseX - stageWidth/2))/(stageWidth/2));				pointM.y = stageHeight-Math.sin(angle)*(stageWidth/2);				if(pageDirect == "left"){									beginDrawing();								}else{									rightFlipDrawing();								}							}		}		private function mouseUpHandler(e:MouseEvent):void{						this.removeEventListener(Event.ENTER_FRAME,beginFlipping);			this.removeEventListener(Event.ENTER_FRAME,rightFlipping);			if(flipping){								if(!sndChannel.position){										stage.removeEventListener(MouseEvent.MOUSE_UP,mouseUpHandler);					sndChannel = snd.play(0,1,sndTransform);					sndChannel.addEventListener(Event.SOUND_COMPLETE,resumeSound);									}				this.addEventListener(Event.ENTER_FRAME,autoFlipping);							}					}		private function resumeSound(e:Event):void{						sndChannel.stop();			sndChannel.removeEventListener(Event.SOUND_COMPLETE,resumeSound);					}		private function autoFlipping(e:Event):void{					if(pointM.x >= stageWidth/2){								pointM.x += (stageWidth-pointM.x)/4;								if(pointM.x >= (stageWidth-0.1)){										shadowMC.x = stageWidth+100;					removeChild(masker1);					removeChild(shadowMasker);					removeChild(masker);					this.removeEventListener(Event.ENTER_FRAME,autoFlipping);					flipping = false;					this["mc"+(n-1)].play();					if(pageDirect == "right"){												this["p"+(n-2)].mask = null;						this["mc"+(n-1)].getChildAt(0).x = 0;						this["mc"+(n-1)].x = stageWidth;						this["mc"+(n-1)].y = stageHeight;						this["mc"+(n-1)].mask = null;						if(n == 1){														flipRight.visible = true;							flipLeft.visible = false;													}else{							trace("b:"+n);							flipLeft.visible = true;							n--;													}											}					return;								}							}else{								pointM.x += (0-pointM.x)/4;				if(pointM.x <= 0.1){										flipLeft.addEventListener(MouseEvent.MOUSE_DOWN,mouseDownHandler);					stage.addEventListener(MouseEvent.MOUSE_UP,mouseUpHandler);					removeChild(masker1);					if(pageDirect == "left"){												this["p"+n].mask = null;						this["mc"+n].x = 0;						this["mc"+n].y = stageHeight;						this["mc"+n].mask = null;						this["mc"+n].play();						this["mc"+n].getChildAt(0).x = -stageWidth;						shadowMC.x = stageWidth+100;											}					removeChild(shadowMasker);					removeChild(masker);					this.removeEventListener(Event.ENTER_FRAME,autoFlipping);					flipping = false;					if(pageDirect == "left"){												if(n == pages){													flipLeft.visible = false;							flipRight.visible = true;							n++;												}else{													flipLeft.visible = true;							n++;							trace("a:"+n);												}											}else{												if(n == 0){													flipRight.visible = false;												}											}					this["mc"+(n-2)].gotoAndStop(1);					return;								}							}			pointM.y += (stageHeight-pointM.y)/4;			if(pageDirect == "left"){								beginDrawing();							}else{								rightFlipDrawing();							}					}		private function beginDrawing():void{						this["mc"+n].x = pointM.x;			this["mc"+n].y = pointM.y;			var md:Number = Point.distance(pointD,pointM);			var dl:Number = stageWidth-pointM.x;			var ml:Number = stageHeight-pointM.y;			var mdl:Number = Math.atan2(ml,dl);			var dh:Number = md/2/Math.sin(mdl);			var di:Number = md/2/Math.cos(mdl);			pointH.x = pointD.x;			pointH.y = pointD.y-dh;			pointI.x = pointD.x - di;			pointI.y = pointD.y;			if(pointH.y>pointB.y){								pointK.x = pointH.x;				pointK.y = pointH.y;							}else{								var bh:Number = Math.tan(mdl)*(dh-stageHeight);				if(!bh){					bh = stageWidth/2;									}				var kha:Number = mdl*2;				pointK.x = pointB.x - (Math.cos(kha)*bh+bh)				pointK.y = -(Math.sin(kha)*bh);				pointH.x = pointB.x - bh;				pointH.y = pointB.y;							}			masker.graphics.clear();			masker.graphics.beginFill(0x000000,1.0);			masker.graphics.moveTo(pointM.x,pointM.y);			masker.graphics.lineTo(pointK.x,pointK.y);			masker.graphics.lineTo(pointH.x,pointH.y);			masker.graphics.lineTo(pointI.x,pointI.y);			masker.graphics.lineTo(pointM.x,pointM.y);			masker.graphics.endFill();			this["mc"+n].rotation = 2*mdl*180/Math.PI;			addChild(masker);			this["mc"+n].mask = masker;			shadowMasker.graphics.clear();			shadowMasker.graphics.beginFill(0x000000,1.0);			shadowMasker.graphics.moveTo(pointM.x,pointM.y);			shadowMasker.graphics.lineTo(pointK.x,pointK.y);			shadowMasker.graphics.lineTo(pointH.x,pointH.y);			shadowMasker.graphics.lineTo(pointB.x,pointB.y);			shadowMasker.graphics.lineTo(pointD.x,pointD.y);			shadowMasker.graphics.lineTo(pointI.x,pointI.y);			shadowMasker.graphics.lineTo(pointM.x,pointM.y);			shadowMasker.graphics.endFill();			addChild(shadowMasker);			shadowMC.mask = shadowMasker;			shadowMC.x = pointI.x;			shadowMC.y = pointI.y;			shadowMC.rotation = mdl*180/Math.PI;			masker1.graphics.clear();			masker1.graphics.beginFill(0x000000,1.0);			masker1.graphics.moveTo(pointD.x,pointD.y);			masker1.graphics.lineTo(pointI.x,pointI.y);			masker1.graphics.lineTo(pointH.x,pointH.y);			masker1.graphics.lineTo(pointB.x,pointB.y);			masker1.graphics.lineTo(pointD.x,pointD.y);			masker1.graphics.endFill();			addChild(masker1);			this["p"+n].mask = masker1;			this["p"+n].visible = true;					}				/************************************************/		/***************** flip to right ****************/		/************************************************/				private function down_flipRight(e:MouseEvent):void{						shadowMC.x = -100;			flipping = true;			pageDirect = "right";			this.setChildIndex(this["mc"+(n-2)],(this.numChildren-4));			this.setChildIndex(this["p"+(n-2)],(this.numChildren-5));			this.addEventListener(Event.ENTER_FRAME,rightFlipping);					}		private function rightFlipping(e:Event):void{						if(mouseX > stageWidth && mouseY < stageHeight && mouseX > 0){															}else if(mouseX < stageWidth && mouseX > 0 && mouseY > stageHeight){															}else if(mouseX > 0 && mouseX < stageWidth && mouseY > 0 && mouseY < stageHeight && hitCircle.hitTestPoint(mouseX,mouseY,true) == true){								pointM.x = mouseX;				pointM.y = mouseY;				rightFlipDrawing();							}else if(mouseX > 0 && mouseX < stageWidth && mouseY > 0 && mouseY < stageHeight && hitCircle.hitTestPoint(mouseX,mouseY,true) == false){								pointM.x = mouseX;				var angle:Number				angle = Math.acos(Math.abs((mouseX - stageWidth/2))/(stageWidth/2));				pointM.y = stageHeight-Math.sin(angle)*(stageWidth/2);				rightFlipDrawing();							}		}		private function rightFlipDrawing():void{						this["mc"+(n-2)].x = pointM.x;			this["mc"+(n-2)].y = pointM.y;			var mc:Number = Point.distance(pointC,pointM);			var cl:Number = pointM.x;			var ml:Number = stageHeight-pointM.y;			var mcl:Number = Math.atan2(ml,cl);			var ch:Number = mc/2/Math.sin(mcl);			pointH.x = pointC.x;			pointH.y = pointC.y-ch;			pointI.x = mc/2/Math.cos(mcl);			pointI.y = pointC.y;			if(pointH.y>pointA.y){								pointK.x = pointH.x;				pointK.y = pointH.y;							}else{								var ah:Number = Math.tan(mcl)*(ch-stageHeight);				if(!ah){					ah = stageWidth/2;									}				var khb:Number = mcl*2;				pointK.x = (Math.cos(khb)*ah+ah)				pointK.y = -(Math.sin(khb)*ah);				pointH.x = ah;				pointH.y = pointA.y;							}			masker.graphics.clear();			masker.graphics.beginFill(0x000000,1.0);			masker.graphics.moveTo(pointM.x,pointM.y);			masker.graphics.lineTo(pointK.x,pointK.y);			masker.graphics.lineTo(pointH.x,pointH.y);			masker.graphics.lineTo(pointI.x,pointI.y);			masker.graphics.lineTo(pointM.x,pointM.y);			masker.graphics.endFill();			this["mc"+(n-2)].rotation = -2*mcl*180/Math.PI;			addChild(masker);			this["mc"+(n-2)].mask = masker;			shadowMasker.graphics.clear();			shadowMasker.graphics.beginFill(0x000000,1.0);			shadowMasker.graphics.moveTo(pointM.x,pointM.y);			shadowMasker.graphics.lineTo(pointK.x,pointK.y);			shadowMasker.graphics.lineTo(pointH.x,pointH.y);			shadowMasker.graphics.lineTo(pointA.x,pointA.y);			shadowMasker.graphics.lineTo(pointC.x,pointC.y);			shadowMasker.graphics.lineTo(pointI.x,pointI.y);			shadowMasker.graphics.lineTo(pointM.x,pointM.y);			shadowMasker.graphics.endFill();			addChild(shadowMasker);			shadowMC.mask = shadowMasker;			shadowMC.x = pointI.x;			shadowMC.y = pointI.y;			shadowMC.rotation = -mcl*180/Math.PI;			masker1.graphics.clear();			masker1.graphics.beginFill(0x000000,1.0);			masker1.graphics.moveTo(pointC.x,pointC.y);			masker1.graphics.lineTo(pointI.x,pointI.y);			masker1.graphics.lineTo(pointH.x,pointH.y);			masker1.graphics.lineTo(pointA.x,pointA.y);			masker1.graphics.lineTo(pointC.x,pointC.y);			masker1.graphics.endFill();			addChild(masker1);			this["p"+(n-2)].mask = masker1;			this["p"+(n-2)].visible = true;					}			}	}