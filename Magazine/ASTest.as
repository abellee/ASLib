package{		import flash.events.MouseEvent;	import flash.events.Event;	import flash.geom.Point;	import flash.display.Shape;	import flash.display.MovieClip;	public class ASTest extends MovieClip{				private var pointA:Point = new Point(0,0);		private var pointB:Point = new Point(550,0);		private var pointC:Point = new Point(0,400);		private var pointD:Point = new Point(550,400);		private var pointG:Point = new Point(225,200);		private var pointH:Point = new Point();		private var pointI:Point = new Point();		private var pointL:Point = new Point();		private var pointM:Point; // mouseX mouseY		private var pointK:Point = new Point();		private var masker:Shape = new Shape();		private var masker1:Shape = new Shape();		private var n:uint=1;		public function ASTest(){						mc2.mask = masker1;			area.addEventListener(MouseEvent.MOUSE_DOWN,pointMHandler);			area.addEventListener(MouseEvent.MOUSE_OVER,alertDrag);			area.addEventListener(MouseEvent.MOUSE_OUT,resumeInit);			area1.addEventListener(MouseEvent.MOUSE_DOWN,backPointM);			area1.addEventListener(MouseEvent.MOUSE_OVER,backAlertDrag);			area1.addEventListener(MouseEvent.MOUSE_OUT,backResumeInit);			//this.addEventListener(Event.ENTER_FRAME,checkN);					}		private function checkN(e:Event):void{						if(n>1){								area1.addEventListener(MouseEvent.MOUSE_DOWN,pointMHandler);				area1.addEventListener(MouseEvent.MOUSE_OVER,alertDrag);				area1.addEventListener(MouseEvent.MOUSE_OUT,resumeInit);							}else{								area1.removeEventListener(MouseEvent.MOUSE_DOWN,pointMHandler);				area1.removeEventListener(MouseEvent.MOUSE_OVER,alertDrag);				area1.removeEventListener(MouseEvent.MOUSE_OUT,resumeInit);							}			if(n == 4){								area.removeEventListener(MouseEvent.MOUSE_DOWN,pointMHandler);				area.removeEventListener(MouseEvent.MOUSE_OVER,alertDrag);				area.removeEventListener(MouseEvent.MOUSE_OUT,resumeInit);							}					}		private function alertDrag(e:MouseEvent):void{			pointM = new Point(550,400)			mc1.alpha = 1;			this.addEventListener(Event.ENTER_FRAME,forWards);					}		private function resumeInit(e:MouseEvent):void{						this.removeEventListener(Event.ENTER_FRAME,forWards);			this.removeEventListener(Event.ENTER_FRAME,drawMasker);			this.addEventListener(Event.ENTER_FRAME,backWards);					}		private function forWards(e:Event):void{						pointM.x += (mouseX - pointM.x)/2;			pointM.y += (mouseY - pointM.y)/2;			mc1.x = pointM.x;			mc1.y = pointM.y;			beginDrawing();					}		private function backWards(e:Event):void{						pointM.x += (550 - pointM.x)/2;			pointM.y += (400 - pointM.y)/2;			mc1.x = pointM.x;			mc1.y = pointM.y;			beginDrawing();					}		private function autoFlip(e:MouseEvent):void{						this.addEventListener(Event.ENTER_FRAME,checkPointM);					}		private function checkPointM(e:Event):void{						this.removeEventListener(MouseEvent.MOUSE_UP,autoFlip);			this.removeEventListener(Event.ENTER_FRAME,drawMasker);			if(pointM.x < 275){								if(pointM.x <= 1){									this.removeEventListener(Event.ENTER_FRAME,checkPointM);					area.addEventListener(MouseEvent.MOUSE_OVER,alertDrag);					area.addEventListener(MouseEvent.MOUSE_OUT,resumeInit);					mc1.mask = null;					n = n+1;					pointM = new Point(550,400);					mc1.alpha = 0;					return;								}else{										pointM.x += (0-pointM.x)/2;									}							}			if(pointM.x > 275){								if(pointM.x >=549){										this.removeEventListener(Event.ENTER_FRAME,checkPointM);					area.addEventListener(MouseEvent.MOUSE_OVER,alertDrag);					area.addEventListener(MouseEvent.MOUSE_OUT,resumeInit);					return;									}else{										pointM.x += (550-pointM.x)/2;									}							}			pointM.y += (400-pointM.y)/2;			mc1.x = pointM.x;			mc1.y = pointM.y;			beginDrawing();					}		private function pointMHandler(e:MouseEvent):void{						area.removeEventListener(MouseEvent.MOUSE_OVER,alertDrag);			area.removeEventListener(MouseEvent.MOUSE_OUT,resumeInit);			this.removeEventListener(Event.ENTER_FRAME,backWards);			this.removeEventListener(Event.ENTER_FRAME,forWards);			this.addEventListener(MouseEvent.MOUSE_UP,autoFlip);			this.addEventListener(Event.ENTER_FRAME,drawMasker);					}		private function drawMasker(e:Event):void{						if(circle.hitTestPoint(mouseX,mouseY,true)){								pointM.x += (mouseX - pointM.x)/2;				pointM.y += (mouseY - pointM.y)/2;							}else{								if(mouseX > 550){										var len:Number = 275-(mouseX-550);					pointM.x += (len +275 - pointM.x)/2;					pointM.y += (400-Math.sqrt(275*275-len*len) - pointM.y)/2;									}else{										var lena:Number = Math.abs(mouseX-275);					pointM.x += (Math.abs(mouseX) - pointM.x)/2;					pointM.y += (400-Math.sqrt(275*275-lena*lena) - pointM.y)/2;									}							}			mc1.x = pointM.x;			mc1.y = pointM.y;			beginDrawing();					}		private function beginDrawing():void{						var md:Number = Point.distance(pointD,pointM);			var dl:Number = 550-pointM.x;			var ml:Number = 400-pointM.y;			var mdl:Number = Math.atan2(ml,dl);			var dh:Number = md/2/Math.sin(mdl);			pointH.x = pointD.x;			pointH.y = pointD.y-dh;			pointI.x = pointD.x - md/2/Math.cos(mdl);			pointI.y = pointD.y;			if(pointH.y>pointB.y){								pointK.x = pointH.x;				pointK.y = pointH.y;							}else{								var bh:Number = Math.tan(mdl)*(dh-400);				var kha:Number = mdl*2;				pointK.x = pointB.x - (Math.cos(mdl/2)*bh+bh)				pointK.y = -(Math.sin(kha)*bh);				pointH.x = pointB.x - bh;				pointH.y = pointB.y;							}			masker.graphics.clear();			masker.graphics.beginFill(0x000000,1.0);			masker.graphics.moveTo(pointM.x,pointM.y);			masker.graphics.lineTo(pointK.x,pointK.y);			masker.graphics.lineTo(pointH.x,pointH.y);			masker.graphics.lineTo(pointI.x,pointI.y);			masker.graphics.lineTo(pointM.x,pointM.y);			masker.graphics.endFill();			mc1.rotation = 2*mdl*180/Math.PI;			mc1.mask = masker;			masker1.graphics.clear();			masker1.graphics.beginFill(0xffffff,1.0);			masker1.graphics.moveTo(pointD.x,pointD.y);			masker1.graphics.lineTo(pointI.x,pointI.y);			masker1.graphics.lineTo(pointH.x,pointH.y);			masker1.graphics.lineTo(pointB.x,pointB.y);			masker1.graphics.lineTo(pointD.x,pointD.y);			masker1.graphics.endFill();			mc2.mask = masker1;					}	private function backPointM(e:MouseEvent):void{					area.removeEventListener(MouseEvent.MOUSE_DOWN,pointMHandler);			area.removeEventListener(MouseEvent.MOUSE_OVER,alertDrag);			area.removeEventListener(MouseEvent.MOUSE_OUT,resumeInit);						area1.removeEventListener(MouseEvent.MOUSE_OVER,backAlertDrag);			area1.removeEventListener(MouseEvent.MOUSE_OUT,backResumeInit);			this.removeEventListener(Event.ENTER_FRAME,backForwards);			this.removeEventListener(Event.ENTER_FRAME,backBackwards);						this.addEventListener(MouseEvent.MOUSE_UP,backAutoFlip);			this.addEventListener(Event.ENTER_FRAME,backMasker);				}	private function backMasker(e:Event):void{						if(circle.hitTestPoint(mouseX,mouseY,true)){								pointM.x += (mouseX - pointM.x)/2;				pointM.y += (mouseY - pointM.y)/2;							}else{									pointM.x = pointM.x;					pointM.y = pointM.y;								}			mc3.x = pointM.x;			mc3.y = pointM.y;			backMaskerBegin();					}		private function backMaskerBegin():void{						var md:Number = Point.distance(pointC,pointM);			var dl:Number = pointM.x;			var ml:Number = 400-pointM.y;			var mdl:Number = Math.atan2(ml,dl);			var dh:Number = md/2/Math.sin(mdl);			pointH.x = pointC.x;			pointH.y = pointC.y-dh;			pointI.x = pointC.x + md/2/Math.cos(mdl);			pointI.y = pointC.y;			if(pointH.y>pointA.y){								pointK.x = pointH.x;				pointK.y = pointH.y;							}else{								var bh:Number = Math.tan(mdl)*(dh-400);				var kha:Number = mdl*2;				pointK.x = pointA.x + (Math.cos(mdl/2)*bh+bh)				pointK.y = -(Math.sin(kha)*bh);				pointH.x = pointA.x + bh;				pointH.y = pointA.y;							}			masker.graphics.clear();			masker.graphics.beginFill(0x000000,1.0);			masker.graphics.moveTo(pointM.x,pointM.y);			masker.graphics.lineTo(pointK.x,pointK.y);			masker.graphics.lineTo(pointH.x,pointH.y);			masker.graphics.lineTo(pointI.x,pointI.y);			masker.graphics.lineTo(pointM.x,pointM.y);			masker.graphics.endFill();			mc3.rotation = -2*mdl*180/Math.PI;			mc3.mask = masker;			masker1.graphics.clear();			masker1.graphics.beginFill(0xffffff,1.0);			masker1.graphics.moveTo(pointC.x,pointC.y);			masker1.graphics.lineTo(pointI.x,pointI.y);			masker1.graphics.lineTo(pointH.x,pointH.y);			masker1.graphics.lineTo(pointA.x,pointA.y);			masker1.graphics.lineTo(pointC.x,pointC.y);			masker1.graphics.endFill();			mc2.mask = masker1;					}		private function backAlertDrag(e:MouseEvent):void{						pointM = new Point(0,400);			mc3.alpha = 1;			this.addEventListener(Event.ENTER_FRAME,backForwards);					}		private function backResumeInit(e:MouseEvent):void{						this.removeEventListener(Event.ENTER_FRAME,backForwards);			this.removeEventListener(Event.ENTER_FRAME,backMasker);			this.addEventListener(Event.ENTER_FRAME,backBackwards);					}		private function backForwards(e:Event):void{						pointM.x += (mouseX - pointM.x)/2;			pointM.y += (mouseY - pointM.y)/2;			mc3.x = pointM.x;			mc3.y = pointM.y;			backMaskerBegin();					}		private function backBackwards(e:Event):void{						pointM.x += (0 - pointM.x)/2;			pointM.y += (400 - pointM.y)/2;			mc3.x = pointM.x;			mc3.y = pointM.y;			backMaskerBegin();					}		private function backAutoFlip(e:MouseEvent):void{						this.addEventListener(Event.ENTER_FRAME,checkBackPointM);					}		private function checkBackPointM(e:Event):void{						this.removeEventListener(MouseEvent.MOUSE_UP,backAutoFlip);			this.removeEventListener(Event.ENTER_FRAME,backMasker);			if(pointM.x < 275){								if(pointM.x <= 1){									this.removeEventListener(Event.ENTER_FRAME,checkBackPointM);					area1.addEventListener(MouseEvent.MOUSE_OVER,backAlertDrag);					area1.addEventListener(MouseEvent.MOUSE_OUT,backResumeInit);					area.addEventListener(MouseEvent.MOUSE_DOWN,pointMHandler);					area.addEventListener(MouseEvent.MOUSE_OVER,alertDrag);					area.addEventListener(MouseEvent.MOUSE_OUT,resumeInit);					return;								}else{										pointM.x += (0-pointM.x)/2;									}							}			if(pointM.x > 275){								if(pointM.x >=549){										this.removeEventListener(Event.ENTER_FRAME,checkBackPointM);					area1.addEventListener(MouseEvent.MOUSE_OVER,backAlertDrag);					area1.addEventListener(MouseEvent.MOUSE_OUT,backResumeInit);					area.addEventListener(MouseEvent.MOUSE_DOWN,pointMHandler);					area.addEventListener(MouseEvent.MOUSE_OVER,alertDrag);					area.addEventListener(MouseEvent.MOUSE_OUT,resumeInit);					mc3.mask = null;					mc3.alpha = 0;					pointM = new Point(0,400);					n = n+1;					return;									}else{										pointM.x += (550-pointM.x)/2;									}							}			pointM.y += (400-pointM.y)/2;			mc3.x = pointM.x;			mc3.y = pointM.y;			backMaskerBegin();					}	}}